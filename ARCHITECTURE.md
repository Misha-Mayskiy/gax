# Архитектурные решения GAX

## 1. Выбор микросервисной архитектуры

Мы выбрали микросервисы вместо монолита по следующим причинам:

- **Изоляция сбоев:** Падение `call-service` (SFU) не должно останавливать переписку в `chat-service`.
- **Масштабируемость:** Мы можем запустить 5 экземпляров `media-service` для обработки тяжелых файлов, оставив 1 экземпляр `auth-service`.
- **Разные технологии:** Использование MongoDB для чатов (гибкая схема) и Postgres для пользователей (строгая схема) в рамках одного проекта.

## 2. Выбор технологий (Justification)

### Базы данных

- **PostgreSQL:** Используется в `auth`, `user`, `media`, `search`. Выбран за надежность, ACID-транзакции и реляционную целостность данных.
- **MongoDB:** Используется в `chat-service`. Выбрана из-за высокой скорости записи (Write-heavy нагрузка) и удобства хранения истории сообщений (документоориентированная модель).
- **Redis:** Используется в `room-service` и `call-service`. Выбран для хранения "горячего" состояния (онлайн-статус, состояние плеера), которое меняется часто и не требует вечного хранения на диске.

### Коммуникация

- **gRPC (Inter-service):** Используется для синхронного взаимодействия (например, API Gateway -> User Service). Выбран за строгую типизацию (Protobuf) и производительность выше REST/JSON.
- **Kafka (Event-Driven):** Используется для асинхронных задач (индексация поиска, уведомления). Позволяет `user-service` не ждать, пока `search-service` обновит индекс ElasticSearch.
- **WebSocket:** Используется для Real-time событий (звонки, управление музыкой) в обход Caddy (через Upgrade connection).

### Видеозвонки (SFU)

Мы отказались от P2P (Mesh) в пользу SFU (Selective Forwarding Unit) на базе `pion/webrtc`.

- **Причина:** P2P плохо работает при >3 участниках (нагрузка на CPU клиента растет экспоненциально). SFU позволяет клиенту отправлять 1 поток и получать N потоков, что экономит трафик и ресурсы.

## 3. Схема данных (Data Flow)

**Поиск (Search Flow):**

1. User Service создает пользователя -> Сохраняет в Postgres.
2. User Service пушит событие `UserCreated` в Kafka (топик `users`).
3. Search Service (Consumer) читает топик -> Обновляет индекс ElasticSearch.
4. Клиент делает запрос GET `/search` -> Search Service читает из ElasticSearch.

**Звонок (Call Flow):**

1. Клиент подключается по WebSocket к `call-service`.
2. Обменивается SDP/ICE (Signaling).
3. Отправляет RTP (видео/аудио) по UDP.
4. Сервис маршрутизирует пакеты другим участникам комнаты.

## 4. Паттерны отказоустойчивости

- **Retry:** При старте сервисы пытаются подключиться к БД/Kafka в цикле (до 15 раз), предотвращая падение при "холодном" старте инфраструктуры.
- **Graceful Shutdown:** Все сервисы перехватывают SIGTERM для корректного закрытия соединений.
- **Healthchecks:** Docker Compose проверяет состояние баз данных перед запуском зависимых сервисов.
